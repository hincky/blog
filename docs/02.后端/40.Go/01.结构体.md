---
title: 结构体
date: 2022-11-15 15:41:54
permalink: /pages/1682d9/
categories:
  - 后端
  - Go
tags:
  - Go
author: 
  name: hincky
  link: https://github.com/hincky
---

Go没有多态，继承，重载；Go 所具有的是结构体的概念，可以将一些方法和结构体关联。

## 定义结构体

其实就是相当于java中定义一个类

```go
type Person struct {
    Name String
    age int
}
```

## 声明和初始化

```go
// 基本用法
hincky := Person{ //逗号 , 是必需的。没有它的话，编译器就会报错。
    Name := "hincky",
    age := 25,
}

// 只定义一个，另一个单独获取并赋值
hincky := Person{Name := "hincky"}
hincky.age = 25

// 最简单
hincky := Person{"hincky", 25}
```

### 函数参数传递方式

#### 镜像复制

引用之后做了修改，但是不会影响原来的值

即这种方式，修改的只是原来值的一个副本

```go
func main() {
  hincky := Person{"hincky", 25}
  Super(hincky)
  fmt.Println(hincky.age)
}

// Super 修改了原始值 goku 的复制版本，而不是它本身，所以，Super 中的修改并不影响上层调用者。
func Super(p Person) { //镜像复制
	p.age += 100 //hincky.age的值还是25，而不是125
}
```

#### 指针

这种方式就可以获取到原来的值，而不是副本

```go 
func main() {
  hincky := &Person{"hincky", 25}
  Super(hincky)
  fmt.Println(hincky.age)  // 这里就为125了
}

func Super(p *Person) { //利用指针，来获取原来的值
	p.age += 100 //hincky.age的原值已被修改为125
}
```

复制一个指针比复制一个复杂的结构的消耗小多了。在 64 位的机器上面，一个指针占据 64 bit 的空间。如果我们有一个包含很多字段的结构，创建它的副本将会是一个很昂贵的操作。指针的真正价值在于能够分享它所指向的值。

所以写代码前，要清楚想让 Super 修改 hincky 的副本（用镜像复制）还是修改共享的 hincky 值本身（用指针）呢？




