---
title: java-concurrent
date: 2022-10-29 11:41:05
permalink: /pages/bb6521/
categories: 
  - share
tags: 
  - null
author: 
  name: hincky
  link: https://github.com/hincky
---
# 进程与线程的区别

是否单独占有内存地址空间及其它系统资源（比如I/O）：
- 进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。
- 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。
- 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。

**进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位**

## cpu

**上下文**：是指某一时间点 CPU 寄存器和程序计数器的内容。

- 寄存器：是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。
- 程序计数器：是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。


# java多线程实现

无返回值的run()方法
- 继承Thread类，并重写run方法；
- 实现Runnable接口的run方法；

然后new MyThread().start()执行线程

有返回值的run()方法
- Callable接口
- Future类
- FutureTask接口


## Thread几个常用方法

- currentThread()：静态方法，返回对当前正在执行的线程对象的引用；
- start()：开始执行线程的方法，java虚拟机会调用线程内的run()方法；
- yield()：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，就算当前线程调用了yield()方法，程序在调度的时候，也还有可能继续运行这个线程的；
- sleep()：静态方法，使当前线程睡眠一段时间；
- join()：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是Object类的wait方法实现的；

## Thread类和Runnable接口的比较

- 由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。
- Runnable接口出现更符合面向对象，将线程单独进行对象的封装。
- Runnable接口出现，降低了线程对象和线程任务的耦合性。
- 如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。

所以，我们通常优先使用“实现Runnable接口”这种方式来自定义线程类。


